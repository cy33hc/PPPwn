"""
Use this in the same way as Python's SimpleHTTPServer:

The only difference from SimpleHTTPServer is that RangeHTTPServer supports
'Range:' headers to load portions of files. This is helpful for doing local web
development with genomic data files, which tend to be to large to load into the
browser all at once.
"""

import os
import re
import time
import config
import subprocess
import threading
from http.server import SimpleHTTPRequestHandler
from urllib.parse import *

def copy_byte_range(infile, outfile, start=None, stop=None, bufsize=16*1024):
    """Like shutil.copyfileobj, but only copy a range of the streams.

    Both start and stop are inclusive.
    """
    if start is not None: infile.seek(start)
    while 1:
        to_read = min(bufsize, stop + 1 - infile.tell() if stop else bufsize)
        buf = infile.read(to_read)
        if not buf:
            break
        outfile.write(buf)


BYTE_RANGE_RE = re.compile(r'bytes=(\d+)-(\d+)?$')
def parse_byte_range(byte_range):
    """Returns the two numbers in 'bytes=123-456' or throws ValueError.

    The last number or both numbers may be None.
    """
    if byte_range.strip() == '':
        return None, None

    m = BYTE_RANGE_RE.match(byte_range)
    if not m:
        raise ValueError('Invalid byte range %s' % byte_range)

    first, last = [x and int(x) for x in m.groups()]
    if last and last < first:
        raise ValueError('Invalid byte range %s' % byte_range)
    return first, last


def run_exploit():
    while True:
        print("Starting exploit process")
        if os.path.isfile(os.getcwd() + "/pppwn.exe"):
            p = subprocess.Popen([os.getcwd() + "/pppwn.exe", "--interface", config.interface, "--fw", config.firmware, "--stage1", config.stage1, "--stage2", config.stage2], stdout=subprocess.PIPE, universal_newlines=True)
        else:
            p = subprocess.Popen([os.getcwd() + "/pppwn", "--interface", config.interface, "--fw", config.firmware, "--stage1", config.stage1, "--stage2", config.stage2], stdout=subprocess.PIPE, universal_newlines=True)
        
        for stdout_line in iter(p.stdout.readline, ""):
            print(stdout_line)
        p.stdout.close()
        return_code = p.wait()

        if return_code == 0:
            return

class ExploitRequestHandler(SimpleHTTPRequestHandler):
    """Adds support for HTTP 'Range' requests to SimpleHTTPRequestHandler
       Adds support for starting the PPPwn expliot

    The approach is to:
    - Override send_head to look for 'Range' and respond appropriately.
    - Override copyfile to only transmit a range when requested.
    """

    exploit_thread = None

    def __init__(self, request, client_address, parent):
        super().__init__(request, client_address, parent)

    def send_head(self):
        if 'Range' not in self.headers:
            self.range = None
            return SimpleHTTPRequestHandler.send_head(self)
        try:
            self.range = parse_byte_range(self.headers['Range'])
        except ValueError as e:
            self.send_error(400, 'Invalid byte range')
            return None
        first, last = self.range

        # Mirroring SimpleHTTPServer.py here
        path = self.translate_path(self.path)
        f = None
        ctype = self.guess_type(path)
        try:
            f = open(path, 'rb')
        except IOError:
            self.send_error(404, 'File not found')
            return None

        fs = os.fstat(f.fileno())
        file_len = fs[6]
        if first >= file_len:
            self.send_error(416, 'Requested Range Not Satisfiable')
            return None

        self.send_response(206)
        self.send_header('Content-type', ctype)

        if last is None or last >= file_len:
            last = file_len - 1
        response_length = last - first + 1

        self.send_header('Content-Range',
                         'bytes %s-%s/%s' % (first, last, file_len))
        self.send_header('Content-Length', str(response_length))
        self.send_header('Last-Modified', self.date_time_string(fs.st_mtime))
        self.end_headers()
        return f

    def end_headers(self):
        self.send_header('Accept-Ranges', 'bytes')
        return SimpleHTTPRequestHandler.end_headers(self)

    def copyfile(self, source, outputfile):
        if not self.range:
            return SimpleHTTPRequestHandler.copyfile(self, source, outputfile)

        # SimpleHTTPRequestHandler uses shutil.copyfileobj, which doesn't let
        # you stop the copying before the end of the file.
        start, stop = self.range  # set in send_head()
        copy_byte_range(source, outputfile, start, stop)

    def do_GET(self):
        if self.path == "/__start_exploit__":
            if ExploitRequestHandler.exploit_thread == None or not ExploitRequestHandler.exploit_thread.is_alive():
                ExploitRequestHandler.exploit_thread = threading.Thread(target=run_exploit)
                ExploitRequestHandler.exploit_thread.start()

                time.sleep(3)
                
                if ExploitRequestHandler.exploit_thread.is_alive():
                    self.send_response(200)
                    self.send_header('Content-Type', 'text/plain')
                    self.end_headers()
                    self.wfile.write("Exploit started\n".encode('utf-8'))
                else:
                    self.send_error(500)
                    self.send_header('Content-Type', 'text/plain')
                    self.end_headers()
                    self.wfile.write("Exploit failed to start\n".encode('utf-8'))
            elif ExploitRequestHandler.exploit_thread != None and ExploitRequestHandler.exploit_thread.is_alive():
                self.send_response(200)
                self.send_header('Content-Type', 'text/plain')
                self.end_headers()
                self.wfile.write("Exploited already started\n".encode('utf-8'))
            else:
                self.send_error(500, "Unknown error")
        elif self.path == "/__status_exploit__":
            if ExploitRequestHandler.exploit_thread != None and ExploitRequestHandler.exploit_thread.is_alive():
                self.send_response(200)
                self.send_header('Content-Type', 'text/plain')
                self.end_headers()
                self.wfile.write("Exploit is running\n".encode('utf-8'))
            else:
                self.send_response(200)
                self.send_header('Content-Type', 'text/plain')
                self.end_headers()
                self.wfile.write("Exploit is not running\n".encode('utf-8'))
        else:
            SimpleHTTPRequestHandler.do_GET(self)